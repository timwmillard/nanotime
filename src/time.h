/*
nanotime.h is a single header file library.  It is base from the Go time
package.

The majority of comment in the file a from the Go source.

*/

#ifndef TIME_H
#define TIME_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

/******************************************************************************
 * Header
 * time.h
 ******************************************************************************/
// Copyright 2024 Tim Millard. All rights reserved.
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package time provides functionality for measuring and displaying time.
//
// The calendrical calculations always assume a Gregorian calendar, with
// no leap seconds.
//
// # Monotonic Clocks
//
// Operating systems provide both a “wall clock,” which is subject to
// changes for clock synchronization, and a “monotonic clock,” which is
// not. The general rule is that the wall clock is for telling time and
// the monotonic clock is for measuring time. Rather than split the API,
// in this package the Time returned by time.Now contains both a wall
// clock reading and a monotonic clock reading; later time-telling
// operations use the wall clock reading, but later time-measuring
// operations, specifically comparisons and subtractions, use the
// monotonic clock reading.
//
// For example, this code always computes a positive elapsed time of
// approximately 20 milliseconds, even if the wall clock is changed during
// the operation being timed:
//
//	start := time.Now()
//	... operation that takes 20 milliseconds ...
//	t := time.Now()
//	elapsed := t.Sub(start)
//
// Other idioms, such as time.Since(start), time.Until(deadline), and
// time.Now().Before(deadline), are similarly robust against wall clock
// resets.
//
// The rest of this section gives the precise details of how operations
// use monotonic clocks, but understanding those details is not required
// to use this package.
//
// The Time returned by time.Now contains a monotonic clock reading.
// If Time t has a monotonic clock reading, t.Add adds the same duration to
// both the wall clock and monotonic clock readings to compute the result.
// Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time
// computations, they always strip any monotonic clock reading from their results.
// Because t.In, t.Local, and t.UTC are used for their effect on the interpretation
// of the wall time, they also strip any monotonic clock reading from their results.
// The canonical way to strip a monotonic clock reading is to use t = t.Round(0).
//
// If Times t and u both contain monotonic clock readings, the operations
// t.After(u), t.Before(u), t.Equal(u), t.Compare(u), and t.Sub(u) are carried out
// using the monotonic clock readings alone, ignoring the wall clock
// readings. If either t or u contains no monotonic clock reading, these
// operations fall back to using the wall clock readings.
//
// On some systems the monotonic clock will stop if the computer goes to sleep.
// On such a system, t.Sub(u) may not accurately reflect the actual
// time that passed between t and u.
//
// Because the monotonic clock reading has no meaning outside
// the current process, the serialized forms generated by t.GobEncode,
// t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic
// clock reading, and t.Format provides no format for it. Similarly, the
// constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,
// as well as the unmarshalers t.GobDecode, t.UnmarshalBinary.
// t.UnmarshalJSON, and t.UnmarshalText always create times with
// no monotonic clock reading.
//
// The monotonic clock reading exists only in Time values. It is not
// a part of Duration values or the Unix times returned by t.Unix and
// friends.
//
// Note that the Go == operator compares not just the time instant but
// also the Location and the monotonic clock reading. See the
// documentation for the Time type for a discussion of equality
// testing for Time values.
//
// For debugging, the result of t.String does include the monotonic
// clock reading if present. If t != u because of different monotonic clock readings,
// that difference will be visible when printing t.String() and u.String().
//
// # Timer Resolution
//
// Timer resolution varies depending on the Go runtime, the operating system
// and the underlying hardware.
// On Unix, the resolution is ~1ms.
// On Windows version 1803 and newer, the resolution is ~0.5ms.
// On older Windows versions, the default resolution is ~16ms, but
// a higher resolution may be requested using [golang.org/x/sys/windows.TimeBeginPeriod].


// A zone represents a single time zone such as CET.
typedef struct {
	char name[4]; // abbreviated name, "CET"
	int  offset;  // seconds east of UTC
	bool isDST;   // is this zone Daylight Savings Time?
} nt_zone;

// A zoneTrans represents a single time zone transition.
typedef struct {
	int64_t when;       // transition time, in seconds since 1970 GMT
	uint8_t index;      // the index of the zone that goes into effect at that time
	bool  isstd, isutc; // ignored - no idea what these mean
} nt_zoneTrans;

// A Location maps time instants to the zone in use at that time.
// Typically, the Location represents the collection of time offsets
// in use in a geographical area. For many Locations the time offset varies
// depending on whether daylight savings time is in use at the time instant.
//
// Location is used to provide a time zone in a printed Time value and for
// calculations involving intervals that may cross daylight savings time
// boundaries.
typedef struct {
	char *name;
	nt_zone *zone;    // []zone
    size_t zoneLen;

	nt_zoneTrans *tx; // []zoneTrans
    size_t txLen;

	// The tzdata information can be followed by a string that describes
	// how to handle DST transitions not recorded in zoneTrans.
	// The format is the TZ environment variable without a colon; see
	// https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html.
	// Example string, for America/Los_Angeles: PST8PDT,M3.2.0,M11.1.0
	char *extend;

	// Most lookups will be for the current time.
	// To avoid the binary search through tx, keep a
	// static one-element cache that gives the correct
	// zone for the time when the Location was created.
	// if cacheStart <= t < cacheEnd,
	// lookup can return cacheZone.
	// The units for cacheStart and cacheEnd are seconds
	// since January 1, 1970 UTC, to match the argument
	// to lookup.
	int64_t cacheStart;
	int64_t cacheEnd;
	nt_zone *cacheZone;
} nt_Location;

// A Time represents an instant in time with nanosecond precision.
//
// Programs using times should typically store and pass them as values,
// not pointers. That is, time variables and struct fields should be of
// type time.Time, not *time.Time.
//
// A Time value can be used by multiple goroutines simultaneously except
// that the methods GobDecode, UnmarshalBinary, UnmarshalJSON and
// UnmarshalText are not concurrency-safe.
//
// Time instants can be compared using the Before, After, and Equal methods.
// The Sub method subtracts two instants, producing a Duration.
// The Add method adds a Time and a Duration, producing a Time.
//
// The zero value of Time is January 1, year 1, 00:00:00.000000000 UTC.
// As this time is unlikely to come up in practice, the IsZero method gives
// a simple way of detecting a time that has not been initialized explicitly.
//
// Each time has an associated Location. The methods Local, UTC, and In return a
// Time with a specific Location. Changing the Location of a Time value with
// these methods does not change the actual instant it represents, only the time
// zone in which to interpret it.
//
// Representations of a Time value saved by the GobEncode, MarshalBinary,
// MarshalJSON, and MarshalText methods store the Time.Location's offset, but not
// the location name. They therefore lose information about Daylight Saving Time.
//
// In addition to the required “wall clock” reading, a Time may contain an optional
// reading of the current process's monotonic clock, to provide additional precision
// for comparison or subtraction.
// See the “Monotonic Clocks” section in the package documentation for details.
//
// Note that the Go == operator compares not just the time instant but also the
// Location and the monotonic clock reading. Therefore, Time values should not
// be used as map or database keys without first guaranteeing that the
// identical Location has been set for all values, which can be achieved
// through use of the UTC or Local method, and that the monotonic clock reading
// has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)
// to t == u, since t.Equal uses the most accurate comparison available and
// correctly handles the case when only one of its arguments has a monotonic
// clock reading.
typedef struct Time {
	// wall and ext encode the wall time seconds, wall time nanoseconds,
	// and optional monotonic clock reading in nanoseconds.
	//
	// From high to low bit position, wall encodes a 1-bit flag (hasMonotonic),
	// a 33-bit seconds field, and a 30-bit wall time nanoseconds field.
	// The nanoseconds field is in the range [0, 999999999].
	// If the hasMonotonic bit is 0, then the 33-bit field must be zero
	// and the full signed 64-bit wall seconds since Jan 1 year 1 is stored in ext.
	// If the hasMonotonic bit is 1, then the 33-bit field holds a 33-bit
	// unsigned wall seconds since Jan 1 year 1885, and ext holds a
	// signed 64-bit monotonic clock reading, nanoseconds since process start.
	uint64_t wall;
	int64_t ext;

	// loc specifies the Location that should be used to
	// determine the minute, hour, month, day, and year
	// that correspond to this Time.
	// The nil location means UTC.
	// All UTC times are represented with loc==nil, never loc==&utcLoc.
	nt_Location *loc;
} nt_Time;

extern nt_Location *time_UTC;
extern nt_Location *time_Local;

// A Month specifies a month of the year (January = 1, ...).
typedef enum {
	nt_JANUARY = 1,
	nt_FEBRUARY,
	nt_MARCH,
	nt_APRIL,
	nt_MAY,
	nt_JUNE,
	nt_JULY,
	nt_AUGUST,
	nt_SEPTEMBER,
	nt_OCTOBER,
	nt_NOVEMBER,
	nt_DECEMBER
} nt_Month;

// A Weekday specifies a day of the week (Sunday = 0, ...).
typedef enum {
	nt_SUNDAY = 0,
	nt_MONDAY,
	nt_TUESDAY,
	nt_WEDNESDAY,
	nt_THURSDAY,
	nt_FRIDAY,
	nt_SATURDAY,
} nt_Weekday;

typedef struct {
    int year;
    nt_Month month;
    int day;
} nt_Date;

typedef struct {
    int year, week;
} nt_Week;


typedef struct {
    int hour, min, sec;
} nt_Clock;

struct nt_TimeZone {
    char *name;
    int offset;
};

// A Duration represents the elapsed time between two instants
// as an int64 nanosecond count. The representation limits the
// largest representable duration to approximately 290 years.
typedef int64_t nt_Duration;


void nt_init(void);

nt_Time nt_TimeUTC(nt_Time t);
nt_Time nt_TimeLocal(nt_Time t);
bool nt_TimeAfter(nt_Time t, nt_Time u);
bool nt_Before(nt_Time t, nt_Time u);
int nt_TimeCompare(nt_Time t, nt_Time u);
bool nt_TimeEqual(nt_Time t, nt_Time u);

char *nt_TimeMonthString(nt_Month m);
char *nt_TimeWeekdayString(nt_Weekday d);

bool nt_TimeIsZero(nt_Time t);
nt_Date nt_TimeDate(nt_Time t);
int nt_TimeYear(nt_Time t);
nt_Month nt_TimeMonth(nt_Time t);
int nt_TimeDay(nt_Time t);
nt_Weekday nt_TimeWeekday(nt_Time t);
nt_Week nt_TimeISOWeek(nt_Time t);
nt_Clock  nt_TimeClock(nt_Time t);
int nt_TimeHour(nt_Time t);
int nt_TimeMinute(nt_Time t);
int nt_TimeSecond(nt_Time t);
int nt_TimeNanosecond(nt_Time t);
int nt_TimeYearDay(nt_Time t);
char *nt_DurationString(nt_Duration d);
int64_t nt_DurationNanoseconds(nt_Duration d);
int64_t nt_DurationMicroseconds(nt_Duration d);
int64_t nt_DurationMilliseconds(nt_Duration d);
double nt_DurationSeconds(nt_Duration d);
double nt_DurationMinutes(nt_Duration d);
double nt_DurationHours(nt_Duration d);
nt_Duration  nt_DurationTruncate(nt_Duration d, nt_Duration m);
nt_Duration nt_DurationRound(nt_Duration d, nt_Duration m);
nt_Duration nt_DurationAbs(nt_Duration d);
nt_Time nt_TimeAdd(nt_Time t , nt_Duration d);
nt_Duration nt_TimeSub(nt_Time t, nt_Time u);

struct nt_TimeZone nt_TimeZone(nt_Time t);
int64_t nt_TimeUnix(nt_Time t);
int64_t nt_TimeUnixMilli(nt_Time t);
int64_t nt_TimeUnixMicro(nt_Time t);
int64_t nt_TimeUnixNano(nt_Time t);

nt_Time nt_Unix(int64_t sec, int64_t nsec);

#endif
